<!DOCTYPE html>
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <title>Hello, AR Cube!</title>

  <script src="js/three.js"></script>
  <script src="jsartoolkit5/artoolkit.min.js"></script>
  <script src="jsartoolkit5/artoolkit.api.js"></script>

  <script src="threex/threex-artoolkitsource.js"></script>
  <script src="threex/threex-artoolkitcontext.js"></script>
  <script src="threex/threex-arbasecontrols.js"></script>
  <script src="threex/threex-armarkercontrols.js"></script>
</head>

<body style="margin:0; overflow:hidden; font-family: Monospace;">

<script>
let scene, camera, renderer, clock, deltaTime, totalTime;
let arToolkitSource, arToolkitContext;

let markerRoot1;
let mesh1, cone;

let textureMat, colorMat;
let usingTexture = true;

initialize();
animate();

function initialize() {
  scene = new THREE.Scene();

  scene.add(new THREE.AmbientLight(0xffffff, 0.9));

  camera = new THREE.Camera();
  scene.add(camera);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setClearColor(new THREE.Color("lightgrey"), 0);

  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.style.position = "absolute";
  renderer.domElement.style.top = "0px";
  renderer.domElement.style.left = "0px";
  document.body.appendChild(renderer.domElement);
	renderer.domElement.style.width = "100vw";
	renderer.domElement.style.height = "100vh";
  clock = new THREE.Clock();
  deltaTime = 0;
  totalTime = 0;


  arToolkitSource = new THREEx.ArToolkitSource({ 
	sourceType: "webcam",  
  sourceWidth: 1920,
  sourceHeight: 1080,
  displayWidth: window.innerWidth,
  displayHeight: window.innerHeight });

  function onResize() {
    if (!arToolkitSource) return;

    arToolkitSource.onResize();
    arToolkitSource.copySizeTo(renderer.domElement);

    if (arToolkitContext && arToolkitContext.arController) {
      arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
    }
  }

  arToolkitSource.init(function onReady() {
    onResize();
  });

  window.addEventListener("resize", onResize);

  arToolkitContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: "data/camera_para.dat",
    detectionMode: "mono"
  });

  arToolkitContext.init(function onCompleted() {
    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
  });

  markerRoot1 = new THREE.Group();
  scene.add(markerRoot1);

  new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
    type: "pattern",
    patternUrl: "data/hiro.patt"
  });

  const loader = new THREE.TextureLoader();
  const texture = loader.load(
    "data/texture.png",
    () => console.log("texture.png užkrauta"),
    undefined,
    (err) => console.error("Nepavyko užkrauti data/texture.png", err)
  );

  textureMat = new THREE.MeshBasicMaterial({ map: texture });
  colorMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

  const geometry1 = new THREE.BoxGeometry(1, 1, 1);
  mesh1 = new THREE.Mesh(geometry1, textureMat);
  mesh1.position.y = 0.5;
  mesh1.scale.set(1.3, 1.3, 1.3);
  markerRoot1.add(mesh1);

  const coneGeom = new THREE.ConeGeometry(0.3, 0.8, 32);
  const coneMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  cone = new THREE.Mesh(coneGeom, coneMat);
  cone.position.set(0, 1.6, 0);
  cone.scale.set(1.4, 1.4, 1.4);
  markerRoot1.add(cone);

  window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "c" && mesh1) {
      if (usingTexture) {
        mesh1.material = colorMat;
        mesh1.material.color.setHex(Math.random() * 0xffffff);
        usingTexture = false;
      } else {
        mesh1.material = textureMat;
        usingTexture = true;
      }
    }
  });

  setInterval(() => {
    if (markerRoot1) console.log("marker visible:", markerRoot1.visible);
  }, 1000);
}

function update() {
  if (arToolkitSource && arToolkitSource.ready !== false) {
    arToolkitContext.update(arToolkitSource.domElement);
  }
}

function render() {
  renderer.render(scene, camera);
}

function animate() {
  requestAnimationFrame(animate);
  deltaTime = clock.getDelta();
  totalTime += deltaTime;

  if (mesh1) {
    mesh1.rotation.y += 0.02;
    mesh1.rotation.x += 0.01;
  }
  if (cone) {
    cone.rotation.y -= 0.015;
  }

  update();
  render();
}
</script>

</body>
</html>
